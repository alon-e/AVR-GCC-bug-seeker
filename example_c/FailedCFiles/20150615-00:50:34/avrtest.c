/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.2.0
 * Git version: dcef523
 * Options:   --no-safe-math --no-math64 --no-bitfields --no-consts --no-float --no-divs --max-array-dim 2 --max-array-len-per-dim 8 --max-block-depth 2 --max-block-size 2 --max-expr-complexity 2 --max-funcs 4 --max-struct-fields 2 --max-union-fields 2 --output /specific/a/home/cc/students/cs/alonelmaliah//Desktop/avrTest/WorkFolder/avrtest.c
 * Seed:      3020520546
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   volatile int32_t  f0;
   int32_t  f1;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int32_t g_21 = 0L;
static uint8_t g_24[3][2] = {{1UL,0xC6L},{0xC6L,1UL},{0xC6L,0xC6L}};
static int32_t g_27[1] = {0xA33A4D1BL};
static int32_t * volatile g_29[1] = {&g_27[0]};
static int32_t * volatile g_30[1][2] = {{(void*)0,(void*)0}};
static int32_t * volatile g_31 = &g_27[0];/* VOLATILE GLOBAL g_31 */
static int32_t g_38 = 0x6B6C7E7CL;
static int16_t g_43[4] = {0x2ED4L,0x2ED4L,0x2ED4L,0x2ED4L};
static struct S0 g_47 = {-10L,0L};/* VOLATILE GLOBAL g_47 */
static uint16_t g_49 = 0x0D3DL;
static struct S0 * volatile g_53 = &g_47;/* VOLATILE GLOBAL g_53 */
static int32_t * volatile g_59 = &g_27[0];/* VOLATILE GLOBAL g_59 */
static struct S0 g_60 = {8L,0L};/* VOLATILE GLOBAL g_60 */
static int32_t *g_62[7] = {&g_60.f1,&g_60.f1,&g_60.f1,&g_60.f1,&g_60.f1,&g_60.f1,&g_60.f1};
static uint16_t g_89 = 0x7829L;
static int32_t ** volatile g_95[5][6] = {{(void*)0,&g_62[3],&g_62[3],(void*)0,&g_62[0],(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,&g_62[6]},{(void*)0,(void*)0,&g_62[6],&g_62[6],(void*)0,(void*)0},{&g_62[3],(void*)0,&g_62[0],(void*)0,&g_62[0],(void*)0},{&g_62[0],(void*)0,(void*)0,&g_62[0],&g_62[0],(void*)0}};
static int32_t ** volatile g_96 = (void*)0;/* VOLATILE GLOBAL g_96 */


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_1(void);
static int32_t * func_2(int32_t  p_3, int32_t * p_4, int32_t * p_5);
static struct S0  func_6(int16_t  p_7, uint32_t  p_8);
static struct S0  func_12(int32_t  p_13, int32_t  p_14, int32_t  p_15, int32_t * p_16);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_24 g_21 g_31 g_27 g_38 g_47 g_53 g_59 g_60 g_62 g_89 g_29
 * writes: g_24 g_27 g_21 g_38 g_43 g_47 g_89 g_29 g_62
 */
static int8_t  func_1(void)
{ /* block id: 0 */
    uint8_t *l_22 = (void*)0;
    uint8_t *l_23 = &g_24[0][0];
    int32_t l_28 = 0x402DA3C3L;
    uint16_t *l_48[8] = {&g_49,&g_49,&g_49,&g_49,&g_49,&g_49,&g_49,&g_49};
    int16_t l_50 = (-1L);
    int16_t l_61[4][5] = {{0xA1BFL,0xA1BFL,(-3L),0x2724L,(-3L)},{0xA1BFL,0xA1BFL,(-3L),0x2724L,(-3L)},{0xA1BFL,0xA1BFL,(-3L),0x2724L,(-3L)},{0xA1BFL,0xA1BFL,(-3L),0x2724L,(-3L)}};
    int32_t **l_97 = &g_62[5];
    int i, j;
    (*l_97) = func_2((func_6(((l_50 = (!(((uint8_t)(func_12(((int16_t)(((uint32_t)(g_27[0] = (((((*l_23)++) < g_21) , 0x279AL) <= g_21)) + (uint32_t)l_28) != l_28) >> (int16_t)2), l_28, g_21, &g_21) , g_24[0][0]) >> (uint8_t)l_28) <= l_28))) < g_47.f1), l_28) , l_61[1][0]), g_62[0], g_62[5]);
    for (g_89 = 0; g_89 < 7; g_89 += 1)
    {
        g_62[g_89] = &g_60.f1;
    }
    return g_60.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_31 g_27 g_60.f1 g_89 g_29
 * writes: g_43 g_89 g_29
 */
static int32_t * func_2(int32_t  p_3, int32_t * p_4, int32_t * p_5)
{ /* block id: 43 */
    uint32_t l_67 = 3UL;
    int16_t *l_68 = &g_43[3];
    int32_t l_77 = 4L;
    int32_t l_79 = 1L;
    int32_t l_80 = (-1L);
    int32_t l_81 = 0xF073E42CL;
    int32_t l_82 = 0x8785D54DL;
    int32_t l_83 = 0x961AC8BEL;
    int32_t l_84 = 1L;
    int32_t l_85 = 1L;
    int32_t l_86 = 0L;
    int32_t l_87 = 0xFFCBC420L;
    int32_t l_88[8][7] = {{0xF1EF3A5EL,0xEC7F1FF5L,0x5E3094FCL,7L,(-1L),1L,0xC2FCF81CL},{(-2L),(-1L),0xB7CF170CL,1L,0x64E9E256L,0x5790E36FL,(-2L)},{0x25A641CEL,1L,(-1L),0x64E9E256L,0xC2FCF81CL,0x64E9E256L,(-1L)},{1L,1L,1L,0xF1EF3A5EL,0xEC7F1FF5L,0x5E3094FCL,7L},{(-1L),(-1L),3L,(-1L),0x33C0C381L,0xFA4CEBEEL,0xF1EF3A5EL},{6L,0xEC7F1FF5L,0x33C0C381L,0x64E9E256L,0xEC7F1FF5L,0x25A641CEL,3L},{7L,0x63BB6A5CL,0x5E3094FCL,0xC2FCF81CL,0xC2FCF81CL,0x5E3094FCL,0x63BB6A5CL},{7L,3L,0x25A641CEL,0xEC7F1FF5L,0x64E9E256L,0x33C0C381L,0xEC7F1FF5L}};
    int i, j;
    if (((int16_t)((*l_68) = (((int32_t)(*g_31) + (int32_t)l_67) >= (*p_4))) * (int16_t)0xDCE3L))
    { /* block id: 45 */
        int32_t *l_69 = (void*)0;
        int32_t *l_70 = &g_60.f1;
        int32_t *l_71 = &g_27[0];
        int32_t *l_72 = &g_47.f1;
        int32_t l_73 = 0xCD947E9EL;
        int32_t *l_74 = &g_27[0];
        int32_t *l_75 = (void*)0;
        int32_t *l_76 = (void*)0;
        int32_t *l_78[4][7] = {{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&g_38,&g_38,&g_27[0],&g_38,&g_38,&g_27[0],&g_38},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,&g_38,(void*)0,(void*)0,&g_38,(void*)0,(void*)0}};
        int i, j;
lbl_94:
        ++g_89;
        for (l_87 = 0; (l_87 != 24); l_87 += 6)
        { /* block id: 49 */
            if (l_67)
                goto lbl_94;
        }
    }
    else
    { /* block id: 52 */
        for (l_81 = 0; (l_81 >= 0); l_81 -= 1)
        { /* block id: 55 */
            int i;
            g_29[l_81] = g_29[l_81];
        }
    }
    return &g_21;
}


/* ------------------------------------------ */
/* 
 * reads : g_47 g_53 g_21 g_59 g_27 g_60
 * writes: g_47 g_21 g_27
 */
static struct S0  func_6(int16_t  p_7, uint32_t  p_8)
{ /* block id: 29 */
    uint8_t l_58 = 255UL;
    for (p_7 = (-23); (p_7 <= (-15)); p_7 += 9)
    { /* block id: 32 */
        (*g_53) = g_47;
        for (g_21 = 0; (g_21 != (-14)); g_21 -= 8)
        { /* block id: 36 */
            int32_t *l_56 = &g_21;
            int32_t **l_57 = &l_56;
            (*l_57) = l_56;
            return (*g_53);
        }
    }
    (*g_59) |= l_58;
    return g_60;
}


/* ------------------------------------------ */
/* 
 * reads : g_21 g_31 g_27 g_24 g_38 g_47
 * writes: g_21 g_27 g_38 g_43
 */
static struct S0  func_12(int32_t  p_13, int32_t  p_14, int32_t  p_15, int32_t * p_16)
{ /* block id: 3 */
    uint8_t *l_34 = (void*)0;
    int32_t l_44 = (-7L);
    for (p_15 = 0; (p_15 <= 1); p_15 += 1)
    { /* block id: 6 */
        int32_t l_36 = 0x062CF9E8L;
        for (g_21 = 1; (g_21 >= 0); g_21 -= 1)
        { /* block id: 9 */
            uint16_t l_35 = 0xCC16L;
            int32_t *l_37 = &g_38;
            int i, j;
            (*g_31) &= ((void*)0 != &g_24[g_21][p_15]);
            (*l_37) |= (((((((((int8_t)(((void*)0 == l_34) , 1L) + (int8_t)g_27[0]) && l_35) || p_13) >= 0x77L) & 0x06C49A7EL) < l_36) | g_24[g_21][p_15]) || (-10L));
        }
        for (g_21 = 1; (g_21 >= 0); g_21 -= 1)
        { /* block id: 15 */
            int32_t *l_39 = &g_27[0];
            int16_t *l_42 = &g_43[3];
            (*l_39) &= l_36;
            (*l_39) = (((*l_42) = ((uint16_t)((*l_39) == 65535UL) - (uint16_t)g_21)) , l_44);
        }
    }
    for (p_13 = (-27); (p_13 >= 8); ++p_13)
    { /* block id: 23 */
        p_16 = &p_15;
        if ((*p_16))
            continue;
    }
    return g_47;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_21, "g_21", print_hash_value);
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 2; j++)
        {
            transparent_crc(g_24[i][j], "g_24[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    for (i = 0; i < 1; i++)
    {
        transparent_crc(g_27[i], "g_27[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_38, "g_38", print_hash_value);
    for (i = 0; i < 4; i++)
    {
        transparent_crc(g_43[i], "g_43[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_47.f0, "g_47.f0", print_hash_value);
    transparent_crc(g_47.f1, "g_47.f1", print_hash_value);
    transparent_crc(g_49, "g_49", print_hash_value);
    transparent_crc(g_60.f0, "g_60.f0", print_hash_value);
    transparent_crc(g_60.f1, "g_60.f1", print_hash_value);
    transparent_crc(g_89, "g_89", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 2
XXX total union variables: 0

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 26
   depth: 2, occurrence: 9
   depth: 5, occurrence: 2
   depth: 11, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 31

XXX times a variable address is taken: 41
XXX times a pointer is dereferenced on RHS: 5
breakdown:
   depth: 1, occurrence: 5
XXX times a pointer is dereferenced on LHS: 11
breakdown:
   depth: 1, occurrence: 11
XXX times a pointer is compared with null: 2
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 311

XXX max dereference level: 1
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 30
XXX number of pointers point to pointers: 4
XXX number of pointers point to scalars: 26
XXX number of pointers point to structs: 1
XXX percent of pointers has null in alias set: 29
XXX average alias set size: 1.19

XXX times a non-volatile is read: 46
XXX times a non-volatile is write: 31
XXX times a volatile is read: 3
XXX    times read thru a pointer: 0
XXX times a volatile is write: 4
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 266
XXX percentage of non-volatile access: 91.7

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 28
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 11
   depth: 1, occurrence: 9
   depth: 2, occurrence: 8

XXX percentage a fresh-made variable is used: 28.6
XXX percentage an existing variable is used: 71.4
********************* end of statistics **********************/

