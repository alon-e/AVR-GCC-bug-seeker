/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.2.0
 * Git version: dcef523
 * Options:   --no-safe-math --no-math64 --no-bitfields --no-consts --no-float --no-divs --max-array-dim 2 --max-array-len-per-dim 8 --max-block-depth 2 --max-block-size 2 --max-expr-complexity 2 --max-funcs 4 --max-struct-fields 2 --max-union-fields 2 --output /specific/a/home/cc/students/cs/alonelmaliah//Desktop/avrTest/WorkFolder/avrtest.c
 * Seed:      1748084353
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   volatile int32_t  f0;
   int32_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_14 = (-1L);
static struct S0 g_16[1][3] = {{{0x809D0107L,-3L},{0x809D0107L,-3L},{0x809D0107L,-3L}}};
static struct S0 * volatile g_17[4] = {&g_16[0][0],&g_16[0][0],&g_16[0][0],&g_16[0][0]};
static struct S0 * volatile g_18 = &g_16[0][0];/* VOLATILE GLOBAL g_18 */
static int32_t *g_31 = &g_16[0][2].f1;
static int32_t ** volatile g_30[5] = {&g_31,&g_31,&g_31,&g_31,&g_31};
static int32_t g_65[1][6] = {{(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)}};
static int32_t ** volatile g_67 = &g_31;/* VOLATILE GLOBAL g_67 */
static int8_t g_69 = 0x4CL;


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_1(void);
static int32_t * func_2(int32_t * p_3, int32_t * p_4, int8_t  p_5, int32_t * p_6);
static int32_t * func_7(int32_t * p_8, uint32_t  p_9, uint32_t  p_10, int32_t * p_11, int32_t  p_12);
static int32_t  func_20(int32_t * p_21, int16_t  p_22, struct S0 * p_23, int32_t * p_24);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_14 g_16 g_18 g_31 g_65 g_67 g_69
 * writes: g_16 g_14 g_31 g_69 g_65
 */
static int8_t  func_1(void)
{ /* block id: 0 */
    int32_t *l_13 = &g_14;
    uint8_t l_15 = 0UL;
    int32_t *l_64[1];
    int32_t **l_86 = &g_31;
    int i;
    for (i = 0; i < 1; i++)
        l_64[i] = &g_65[0][4];
    (*l_86) = func_2(func_7(l_13, (*l_13), l_15, &g_14, (*l_13)), l_64[0], g_65[0][4], l_64[0]);
    return (**l_86);
}


/* ------------------------------------------ */
/* 
 * reads : g_67 g_16.f1 g_65 g_69 g_16 g_18 g_14 g_31
 * writes: g_31 g_69 g_16 g_14 g_65
 */
static int32_t * func_2(int32_t * p_3, int32_t * p_4, int8_t  p_5, int32_t * p_6)
{ /* block id: 40 */
    int32_t *l_66 = &g_65[0][4];
    int8_t *l_68 = &g_69;
    int32_t l_73 = (-8L);
    int32_t l_74 = (-1L);
    int32_t l_78 = 7L;
    int32_t l_79 = 1L;
    int32_t l_80[6] = {0x3ED9FA11L,(-1L),0x3ED9FA11L,0x3ED9FA11L,(-1L),0x3ED9FA11L};
    uint32_t l_81 = 18446744073709551615UL;
    int i;
    (*g_67) = l_66;
    if ((((*l_68) = ((0UL != g_16[0][2].f1) , g_65[0][3])) > g_16[0][2].f1))
    { /* block id: 43 */
        int32_t **l_70[1][5] = {{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}};
        int i, j;
        (*g_67) = func_7(p_3, p_5, p_5, p_3, g_69);
        (*p_4) &= (p_5 || g_14);
    }
    else
    { /* block id: 46 */
        int8_t l_71 = 0x00L;
        int32_t l_72[3][3] = {{(-5L),(-5L),(-5L)},{1L,1L,1L},{(-5L),(-5L),(-5L)}};
        int i, j;
        if ((((((&p_3 != &p_3) != (*p_4)) , g_65[0][4]) > p_5) , l_71))
        { /* block id: 47 */
            int32_t *l_75 = &l_72[2][2];
            int32_t *l_76 = (void*)0;
            int32_t *l_77[5][4] = {{&l_72[0][2],&l_72[0][2],(void*)0,(void*)0},{&l_72[0][2],&l_72[0][2],(void*)0,(void*)0},{&l_72[0][2],&l_72[0][2],(void*)0,(void*)0},{&l_72[0][2],&l_72[0][2],(void*)0,(void*)0},{&l_72[0][2],&l_72[0][2],(void*)0,(void*)0}};
            int i, j;
            l_81++;
            (*g_31) &= (-(int32_t)(((((((*l_68) &= 0x6AL) ^ p_5) , g_16[0][2].f1) , g_69) , p_6) != &l_74));
        }
        else
        { /* block id: 51 */
            (*l_66) = (~(((void*)0 != &g_69) , 0x50L));
        }
    }
    return p_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_16 g_18 g_14 g_31 g_65
 * writes: g_16 g_14 g_65
 */
static int32_t * func_7(int32_t * p_8, uint32_t  p_9, uint32_t  p_10, int32_t * p_11, int32_t  p_12)
{ /* block id: 1 */
    uint32_t l_19 = 0xB382E580L;
    int16_t l_25 = 0xE2D3L;
    int32_t l_59 = (-4L);
    int32_t l_60[3][8] = {{0x5878EC11L,0x5878EC11L,0xB8C42DAAL,0L,1L,0L,0xB8C42DAAL,0x5878EC11L},{0x5878EC11L,0L,(-10L),0xB8C42DAAL,0xB8C42DAAL,(-10L),0L,0x5878EC11L},{0L,(-1L),0x5878EC11L,0L,0x5878EC11L,(-1L),0L,0L}};
    int i, j;
    (*g_18) = g_16[0][2];
    for (p_9 = 0; (p_9 <= 0); p_9 += 1)
    { /* block id: 5 */
        uint8_t l_61 = 255UL;
        for (p_10 = 0; (p_10 <= 3); p_10 += 1)
        { /* block id: 8 */
            g_14 &= (l_19 < g_16[0][2].f1);
            if (g_16[0][2].f0)
                break;
        }
        for (p_10 = 0; (p_10 <= 3); p_10 += 1)
        { /* block id: 14 */
            int32_t *l_55 = &g_14;
            int32_t *l_56 = &g_16[0][2].f1;
            int32_t *l_57 = &g_16[0][2].f1;
            int32_t *l_58[6] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
            int i;
            (*p_8) = func_20(&g_14, l_25, &g_16[0][2], &g_14);
            l_61--;
        }
    }
    return p_8;
}


/* ------------------------------------------ */
/* 
 * reads : g_14 g_16 g_31 g_65
 * writes: g_14 g_16 g_65
 */
static int32_t  func_20(int32_t * p_21, int16_t  p_22, struct S0 * p_23, int32_t * p_24)
{ /* block id: 15 */
    int32_t *l_29 = &g_14;
    int32_t l_39[5][8] = {{6L,0x78C6AEE3L,(-1L),0xFE605A42L,(-1L),0x78C6AEE3L,6L,0L},{(-1L),0x78C6AEE3L,6L,0L,0x1F8487B2L,0x1F8487B2L,0L,6L},{0L,0L,0x78C6AEE3L,0x69719EFCL,0x1F8487B2L,0xFE605A42L,1L,0xFE605A42L},{(-1L),6L,0x69719EFCL,6L,(-1L),0x094191B8L,0L,0xFE605A42L},{6L,0x1F8487B2L,1L,0x69719EFCL,0x69719EFCL,1L,0x1F8487B2L,6L}};
    uint32_t l_48 = 1UL;
    int32_t *l_51 = (void*)0;
    int i, j;
    for (g_14 = (-22); (g_14 == 8); g_14 += 7)
    { /* block id: 18 */
        int32_t l_28 = 0xF37D437FL;
        int32_t l_33[3];
        int32_t *l_38 = (void*)0;
        int32_t *l_40 = &l_39[4][0];
        int32_t *l_41 = &l_33[0];
        int32_t *l_42 = &l_28;
        int32_t *l_43 = &l_39[4][0];
        int32_t *l_44[1][4] = {{&l_28,&l_28,&l_28,&l_28}};
        int32_t l_45 = 0x0C1A6FE1L;
        int32_t l_46 = 0x09BDD522L;
        int32_t l_47 = 5L;
        int i, j;
        for (i = 0; i < 3; i++)
            l_33[i] = 1L;
        if (l_28)
        { /* block id: 19 */
            int32_t **l_32 = &l_29;
            (*l_32) = l_29;
            (*p_23) = (*p_23);
        }
        else
        { /* block id: 22 */
            int32_t *l_37 = &l_28;
            l_33[2] ^= ((*g_31) = l_28);
            (*l_37) &= (((uint8_t)((((((((~g_16[0][2].f0) & p_22) <= (*l_29)) == (*g_31)) , (-1L)) , p_22) == l_33[1]) && 0x1B9BL) - (uint8_t)p_22) >= (*g_31));
        }
        ++l_48;
    }
    if (((((l_51 != p_24) != g_16[0][2].f1) || 0xBC801A57L) || 65526UL))
    { /* block id: 29 */
        int8_t l_54 = 0x24L;
        l_54 |= (((uint32_t)g_14 - (uint32_t)p_22) <= 6L);
    }
    else
    { /* block id: 31 */
        return (*p_21);
    }
    return (*l_29);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_14, "g_14", print_hash_value);
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 3; j++)
        {
            transparent_crc(g_16[i][j].f0, "g_16[i][j].f0", print_hash_value);
            transparent_crc(g_16[i][j].f1, "g_16[i][j].f1", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 6; j++)
        {
            transparent_crc(g_65[i][j], "g_65[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_69, "g_69", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 1
XXX total union variables: 0

XXX max expression depth: 10
breakdown:
   depth: 1, occurrence: 31
   depth: 2, occurrence: 7
   depth: 3, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 10, occurrence: 2

XXX total number of pointers: 38

XXX times a variable address is taken: 37
XXX times a pointer is dereferenced on RHS: 10
breakdown:
   depth: 1, occurrence: 9
   depth: 2, occurrence: 1
XXX times a pointer is dereferenced on LHS: 14
breakdown:
   depth: 1, occurrence: 14
XXX times a pointer is compared with null: 1
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 512

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 62
   level: 2, occurrence: 2
XXX number of pointers point to pointers: 5
XXX number of pointers point to scalars: 30
XXX number of pointers point to structs: 3
XXX percent of pointers has null in alias set: 18.4
XXX average alias set size: 1.24

XXX times a non-volatile is read: 66
XXX times a non-volatile is write: 35
XXX times a volatile is read: 2
XXX    times read thru a pointer: 0
XXX times a volatile is write: 3
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 418
XXX percentage of non-volatile access: 95.3

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 31
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 11
   depth: 1, occurrence: 9
   depth: 2, occurrence: 11

XXX percentage a fresh-made variable is used: 17
XXX percentage an existing variable is used: 83
********************* end of statistics **********************/

