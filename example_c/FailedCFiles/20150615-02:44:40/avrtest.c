/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.2.0
 * Git version: dcef523
 * Options:   --no-safe-math --no-math64 --no-bitfields --no-consts --no-float --no-divs --max-array-dim 2 --max-array-len-per-dim 8 --max-block-depth 2 --max-block-size 2 --max-expr-complexity 2 --max-funcs 4 --max-struct-fields 2 --max-union-fields 2 --output /specific/a/home/cc/students/cs/alonelmaliah//Desktop/avrTest/WorkFolder/avrtest.c
 * Seed:      4212376542
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   volatile uint32_t  f1;
};
#pragma pack(pop)

struct S1 {
   int16_t  f0;
   int16_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static struct S1 g_12 = {0L,0L};
static int32_t g_28[3][6] = {{3L,0x9B4CCC41L,3L,3L,0x9B4CCC41L,3L},{3L,0x9B4CCC41L,3L,3L,0x9B4CCC41L,3L},{3L,0x9B4CCC41L,3L,3L,0x9B4CCC41L,3L}};
static int32_t * volatile g_27 = &g_28[1][1];/* VOLATILE GLOBAL g_27 */
static struct S0 g_31 = {4294967295UL,1UL};/* VOLATILE GLOBAL g_31 */
static struct S1 *g_35 = &g_12;
static int32_t * volatile g_36[8] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
static struct S1  func_2(int16_t  p_3, int8_t  p_4, uint32_t  p_5, uint16_t  p_6);
static int8_t  func_15(int32_t  p_16);
static struct S0  func_17(uint32_t  p_18, uint16_t  p_19, uint8_t  p_20, int32_t  p_21);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_12 g_27 g_28 g_31
 * writes: g_28 g_35 g_27
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_7[1];
    int32_t l_8[1][1];
    int32_t l_60 = 0x57D2D520L;
    int i, j;
    for (i = 0; i < 1; i++)
        l_7[i] = 250UL;
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 1; j++)
            l_8[i][j] = 0x43EB6069L;
    }
    l_60 = ((func_2(l_7[0], l_8[0][0], l_8[0][0], l_7[0]) , l_7[0]) , l_7[0]);
    return l_7[0];
}


/* ------------------------------------------ */
/* 
 * reads : g_12 g_27 g_28 g_31
 * writes: g_28 g_35 g_27
 */
static struct S1  func_2(int16_t  p_3, int8_t  p_4, uint32_t  p_5, uint16_t  p_6)
{ /* block id: 1 */
    uint32_t l_9[6][7] = {{0UL,3UL,4294967288UL,0x7DCD66A0L,4294967295UL,4294967295UL,0x7DCD66A0L},{0x3DC0E3E7L,9UL,0x3DC0E3E7L,3UL,0x7DCD66A0L,0x3DC0E3E7L,0UL},{0x7DCD66A0L,9UL,4294967293UL,7UL,9UL,4294967295UL,4294967295UL},{4294967288UL,0xFAF07207L,0xFAF07207L,4294967288UL,1UL,4294967293UL,0x3DC0E3E7L},{4294967295UL,3UL,0xFAF07207L,1UL,0x3DC0E3E7L,4294967295UL,4294967295UL},{3UL,0x3DC0E3E7L,9UL,0x3DC0E3E7L,3UL,0x7DCD66A0L,0x3DC0E3E7L}};
    uint32_t l_23 = 0x1A53FDE7L;
    int32_t l_48 = 0x1E9AD3EEL;
    int32_t l_49 = 7L;
    int8_t l_50 = 0L;
    int32_t l_51[8] = {1L,1L,1L,1L,1L,1L,1L,1L};
    struct S1 l_59[4][7] = {{{0x80BAL,0x3991L},{0x5533L,0x8A3BL},{1L,-1L},{2L,-3L},{2L,-3L},{1L,-1L},{0x5533L,0x8A3BL}},{{2L,-3L},{0x80BAL,0x3991L},{0x4752L,0x806AL},{0xA3DCL,8L},{1L,0L},{9L,4L},{9L,4L}},{{0x4752L,0x806AL},{0x80BAL,0x3991L},{2L,-3L},{0x80BAL,0x3991L},{0x4752L,0x806AL},{0xA3DCL,8L},{1L,0L}},{{1L,-1L},{0x5533L,0x8A3BL},{0x80BAL,0x3991L},{0xA3DCL,8L},{1L,-3L},{0xA3DCL,8L},{0x80BAL,0x3991L}}};
    int i, j;
    l_9[4][5]++;
    if (((g_12 , p_6) == 4UL))
    { /* block id: 3 */
        int32_t l_22 = (-9L);
        int32_t l_40 = (-5L);
        int32_t l_52[7][7] = {{0xDF13F3F2L,0xDF13F3F2L,0L,(-5L),0xD1428A3AL,0L,0xD43E6B0CL},{0x75BC6281L,5L,1L,1L,5L,0x75BC6281L,0x5E333AB1L},{0xE192EF5DL,0L,1L,0L,0xD1428A3AL,0xD1428A3AL,0L},{0xA03F7513L,(-8L),0xA03F7513L,(-2L),0x5E333AB1L,0x6AB569F1L,0x75BC6281L},{1L,0L,0xE192EF5DL,0L,0xE192EF5DL,0L,1L},{1L,5L,0x75BC6281L,0x5E333AB1L,(-2L),0x6AB569F1L,(-2L)},{0L,0xDF13F3F2L,0xDF13F3F2L,0L,(-5L),0xD1428A3AL,0L}};
        uint32_t l_53[1][2];
        int i, j;
        for (i = 0; i < 1; i++)
        {
            for (j = 0; j < 2; j++)
                l_53[i][j] = 0xFF0D8C8EL;
        }
        for (p_3 = 0; (p_3 == 29); p_3 += 7)
        { /* block id: 6 */
            uint8_t l_32 = 0xC8L;
            uint32_t l_38 = 1UL;
            int32_t *l_39 = (void*)0;
            int32_t *l_41 = &g_28[0][2];
            int32_t *l_42 = &g_28[2][1];
            int32_t *l_43 = &g_28[1][1];
            int32_t *l_44 = &l_40;
            int32_t *l_45 = (void*)0;
            int32_t *l_46 = &l_40;
            int32_t *l_47[5] = {&g_28[1][1],&g_28[1][1],&g_28[1][1],&g_28[1][1],&g_28[1][1]};
            int i;
            l_40 |= (((func_15((func_17(((g_12 , 0x02377D64L) && g_12.f1), p_5, l_22, l_23) , l_32)) && l_38) < p_5) & g_31.f0);
            l_53[0][1]++;
        }
        g_27 = &l_52[3][5];
    }
    else
    { /* block id: 19 */
        uint8_t l_56 = 0x16L;
        l_56--;
    }
    return l_59[1][0];
}


/* ------------------------------------------ */
/* 
 * reads : g_27 g_28 g_31.f0
 * writes: g_35 g_28
 */
static int8_t  func_15(int32_t  p_16)
{ /* block id: 11 */
    struct S1 *l_34[5][4] = {{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0}};
    struct S1 **l_33[2];
    int32_t *l_37[5];
    int i, j;
    for (i = 0; i < 2; i++)
        l_33[i] = &l_34[1][1];
    for (i = 0; i < 5; i++)
        l_37[i] = &g_28[1][0];
    g_35 = &g_12;
    (*g_27) = (*g_27);
    return g_31.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_12.f0 g_27 g_28 g_31
 * writes: g_28
 */
static struct S0  func_17(uint32_t  p_18, uint16_t  p_19, uint8_t  p_20, int32_t  p_21)
{ /* block id: 7 */
    uint16_t l_26[7][8] = {{1UL,65535UL,2UL,3UL,0x5E21L,8UL,0x5E21L,3UL},{0x5E21L,8UL,0x5E21L,3UL,2UL,65535UL,1UL,0xEFE8L},{0UL,2UL,0xC53DL,65535UL,65535UL,0xC53DL,2UL,0UL},{0UL,3UL,0x4FE9L,0x5E21L,2UL,65528UL,0xC53DL,65528UL},{0x5E21L,0xAECAL,0xEFE8L,0xAECAL,0x5E21L,65528UL,8UL,2UL},{1UL,3UL,0xAECAL,0UL,0xC53DL,0xC53DL,0UL,0xAECAL},{2UL,2UL,0xAECAL,0UL,0x4FE9L,65535UL,8UL,1UL}};
    int32_t *l_29 = &g_28[1][1];
    int32_t **l_30 = &l_29;
    int i, j;
    (*g_27) &= (((int16_t)(l_26[1][4] , 0x1464L) >> (int16_t)10) == g_12.f0);
    (*l_30) = l_29;
    return g_31;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_12.f0, "g_12.f0", print_hash_value);
    transparent_crc(g_12.f1, "g_12.f1", print_hash_value);
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 6; j++)
        {
            transparent_crc(g_28[i][j], "g_28[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_31.f0, "g_31.f0", print_hash_value);
    transparent_crc(g_31.f1, "g_31.f1", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 19
   depth: 1, occurrence: 3
XXX total union variables: 0

XXX max expression depth: 12
breakdown:
   depth: 1, occurrence: 21
   depth: 2, occurrence: 1
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 7, occurrence: 1
   depth: 12, occurrence: 1

XXX total number of pointers: 16

XXX times a variable address is taken: 16
XXX times a pointer is dereferenced on RHS: 1
breakdown:
   depth: 1, occurrence: 1
XXX times a pointer is dereferenced on LHS: 3
breakdown:
   depth: 1, occurrence: 3
XXX times a pointer is compared with null: 0
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 304

XXX max dereference level: 1
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 5
XXX number of pointers point to pointers: 2
XXX number of pointers point to scalars: 12
XXX number of pointers point to structs: 2
XXX percent of pointers has null in alias set: 25
XXX average alias set size: 1.25

XXX times a non-volatile is read: 27
XXX times a non-volatile is write: 11
XXX times a volatile is read: 1
XXX    times read thru a pointer: 0
XXX times a volatile is write: 3
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 286
XXX percentage of non-volatile access: 90.5

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 16
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 11
   depth: 1, occurrence: 3
   depth: 2, occurrence: 2

XXX percentage a fresh-made variable is used: 23.9
XXX percentage an existing variable is used: 76.1
********************* end of statistics **********************/

